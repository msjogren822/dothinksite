<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Dogify Your Photo</title>
  <meta name="description" content="Capture your selfie and let AI add a cute dog to your scene! Free AI photo editing with Venice.ai" />
  <meta property="og:title" content="$DOGify your image!" />
  <meta property="og:description" content="Capture your selfie and let AI add a cute dog to your scene!" />
  <meta property="og:url" content="https://www.dothink.in/dogify.html" />
  <meta property="og:type" content="website" />
  <meta name="twitter:card" content="summary_large_image" />
  <meta name="twitter:title" content="$DOGify your image!" />
  <meta name="twitter:description" content="Capture your selfie and let AI add a cute dog to your scene!" />
  <link rel="stylesheet" href="/assets/css/dogify.css">
</head>
<body>
  <script async src='https://static.addtoany.com/menu/page.js'></script>
  <h1>$dog-ify Your Photo</h1>
  <p>Capture a photo and let AI add $dog to your scene! (processing time, about 30 seconds)</p>

  <!-- Save Toggle Section -->
  <div class="save-toggle-section">
    <div class="toggle-container">
      <label class="toggle-label" for="save-toggle">
        <input type="checkbox" id="save-toggle" class="toggle-input">
        <span class="toggle-slider"></span>
        <span class="toggle-text">Save the generated image for easier sharing</span>
      </label>
    </div>
    <div class="save-disclaimer">
      <small>Your captured image is <strong>NOT SAVED</strong>, only your generated image will be with your permission. Your generated image is based on text descriptions of your captured image so it is safe to store for sharing.</small>
    </div>
  </div>

  <div class="camera-start-section">
    <div class="start-label">Start Camera:</div>
    <div class="camera-options">
      <button id="start-camera-front" class="camera-option-button">ü§≥<br><small>Front</small></button>
      <button id="start-camera-back" class="camera-option-button">üì∑<br><small>Back</small></button>
    </div>
  </div>

  <!-- Camera view with side buttons -->
  <div class="camera-container">
    <button id="capture-left" class="side-button" style="display: none;">üì∏</button>
    
    <video id="video" autoplay playsinline style="display: none;"></video>
    <canvas id="canvas" style="display: none;"></canvas>
    
    <button id="capture-right" class="side-button" style="display: none;">üì∏</button>
  </div>

  <!-- Dogify buttons (same layout) -->
  <div class="camera-container" id="dogify-container" style="display: none;">
    <button id="dogify-left" class="side-button" disabled>üêï</button>
    
    <div style="width: min(90vw, 500px); height: 20px;"></div> <!-- Spacer to maintain alignment -->
    
    <button id="dogify-right" class="side-button" disabled>üêï</button>
  </div>

  <div id="status"></div>
  <img id="dogified-image" alt="AI Generated Image" style="display: none;" />
  
  <!-- Share bar - only shows after image is generated -->
  <div id="share-container" style="display: none;">
    <!-- AddToAny widget will be dynamically created here -->
  </div>

  <!-- Technical Details Accordion -->
  <div id="tech-details" class="accordion" style="display: none;">
    <div class="accordion-header" onclick="toggleAccordion()">
      <span class="accordion-toggle">‚ñ∂</span>
      <span>Prompt Details</span>
    </div>
    <div class="accordion-content">
      <div class="accordion-section">
        <h4>What the AI Saw:</h4>
        <div class="content-box" id="scene-analysis"></div>
      </div>
      <div class="accordion-section">
        <h4>Generation Prompt Used:</h4>
        <div class="content-box" id="generation-prompt"></div>
      </div>
    </div>
  </div>

  <script>
    const startCameraFrontBtn = document.getElementById('start-camera-front');
    const startCameraBackBtn = document.getElementById('start-camera-back');
    const video = document.getElementById('video');
    const canvas = document.getElementById('canvas');
    const captureLeftBtn = document.getElementById('capture-left');
    const captureRightBtn = document.getElementById('capture-right');
    const dogifyLeftBtn = document.getElementById('dogify-left');
    const dogifyRightBtn = document.getElementById('dogify-right');
    const dogifyContainer = document.getElementById('dogify-container');
    const statusEl = document.getElementById('status');
    const dogifiedImgEl = document.getElementById('dogified-image');
    const techDetails = document.getElementById('tech-details');
    const sceneAnalysisEl = document.getElementById('scene-analysis');
    const generationPromptEl = document.getElementById('generation-prompt');

    const specialDogURL = '/assets/images/special_dog.png';

    let stream = null;
    let capturedImageData = '';

    // Copy share URL function
    function copyShareUrl() {
      const shareUrlInput = document.getElementById('share-url');
      shareUrlInput.select();
      shareUrlInput.setSelectionRange(0, 99999); // For mobile devices
      navigator.clipboard.writeText(shareUrlInput.value).then(() => {
        const button = event.target;
        const originalText = button.innerHTML;
        button.innerHTML = '‚úÖ Copied!';
        button.style.background = '#28a745';
        setTimeout(() => {
          button.innerHTML = originalText;
          button.style.background = '#0070f3';
        }, 2000);
      }).catch(() => {
        // Fallback for older browsers
        document.execCommand('copy');
        alert('Share URL copied to clipboard!');
      });
    }

    // Check for shared image on page load - removed since we're using /share/{id} URLs now

    // Accordion toggle function
    function toggleAccordion() {
      const content = document.querySelector('.accordion-content');
      const toggle = document.querySelector('.accordion-toggle');
      
      content.classList.toggle('expanded');
      toggle.classList.toggle('expanded');
    }

    // Start the webcam with specified facing mode
    async function startCamera(facingMode = 'user') {
      try {
        const activeBtn = facingMode === 'user' ? startCameraFrontBtn : startCameraBackBtn;
        const otherBtn = facingMode === 'user' ? startCameraBackBtn : startCameraFrontBtn;
        
        activeBtn.classList.add('button-active');
        activeBtn.innerHTML = facingMode === 'user' ? 'üîÑ<br><small>Starting...</small>' : 'üîÑ<br><small>Starting...</small>';
        activeBtn.disabled = true;
        otherBtn.disabled = true;
        
        const constraints = {
          video: {
            facingMode: facingMode
          }
        };
        
        stream = await navigator.mediaDevices.getUserMedia(constraints);
        video.srcObject = stream;
        video.style.display = 'block';
        
        // Show side capture buttons with glow effect
        captureLeftBtn.style.display = 'flex';
        captureRightBtn.style.display = 'flex';
        captureLeftBtn.classList.add('button-capture');
        captureRightBtn.classList.add('button-capture');
        
        // Hide camera start buttons
        startCameraFrontBtn.style.display = 'none';
        startCameraBackBtn.style.display = 'none';
        
        const cameraType = facingMode === 'user' ? 'Front' : 'Back';
        statusEl.innerHTML = `üìπ <strong>${cameraType} camera ready!</strong><br>Tap either capture button when ready.`;
        
      } catch (err) {
        const activeBtn = facingMode === 'user' ? startCameraFrontBtn : startCameraBackBtn;
        const otherBtn = facingMode === 'user' ? startCameraBackBtn : startCameraFrontBtn;
        
        activeBtn.classList.remove('button-active');
        activeBtn.innerHTML = facingMode === 'user' ? 'ü§≥<br><small>Front</small>' : 'üì∑<br><small>Back</small>';
        activeBtn.disabled = false;
        otherBtn.disabled = false;
        statusEl.innerHTML = `üö® Camera error: ${err.message}`;
      }
    }

    // Add event listeners for both camera buttons
    startCameraFrontBtn.addEventListener('click', () => startCamera('user'));
    startCameraBackBtn.addEventListener('click', () => startCamera('environment'));

    // Capture function for both buttons
    function capturePhoto() {
      captureLeftBtn.classList.remove('button-capture');
      captureRightBtn.classList.remove('button-capture');
      captureLeftBtn.classList.add('button-active');
      captureRightBtn.classList.add('button-active');
      
      canvas.width = video.videoWidth;
      canvas.height = video.videoHeight;
      canvas.getContext('2d').drawImage(video, 0, 0);
      capturedImageData = canvas.toDataURL('image/png', 0.8);
      
      canvas.style.display = 'block';
      video.style.display = 'none';
      
      // Smoothly transition capture buttons to dogify buttons
      captureLeftBtn.innerHTML = 'üêï';
      captureRightBtn.innerHTML = 'üêï';
      captureLeftBtn.classList.remove('button-active');
      captureRightBtn.classList.remove('button-active');
      captureLeftBtn.classList.add('button-capture');
      captureRightBtn.classList.add('button-capture');
      
      // Transfer functionality to dogify
      captureLeftBtn.removeEventListener('click', capturePhoto);
      captureRightBtn.removeEventListener('click', capturePhoto);
      captureLeftBtn.addEventListener('click', dogifyPhoto);
      captureRightBtn.addEventListener('click', dogifyPhoto);
      
      // Hide dogify container since we're reusing capture buttons
      dogifyContainer.style.display = 'none';
      
      if (stream) {
        stream.getTracks().forEach(track => track.stop());
      }
      
      statusEl.innerHTML = 'üì∏ <strong>Photo captured!</strong> Now tap either button to add $dog!';
    }

    // Add capture listeners to both buttons
    captureLeftBtn.addEventListener('click', capturePhoto);
    captureRightBtn.addEventListener('click', capturePhoto);

    // Fetch an image and convert it to a data URL
    async function fetchImageAsDataURL(url) {
      const response = await fetch(url);
      const blob = await response.blob();
      return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onloadend = () => resolve(reader.result);
        reader.onerror = reject;
        reader.readAsDataURL(blob);
      });
    }

    // Dogify function for both buttons
    async function dogifyPhoto() {
      try {
        captureLeftBtn.classList.remove('button-capture');
        captureRightBtn.classList.remove('button-capture');
        captureLeftBtn.classList.add('button-active');
        captureRightBtn.classList.add('button-active');
        captureLeftBtn.disabled = true;
        captureRightBtn.disabled = true;
        
        const functionName = 'venice-dogify';
        
        let seconds = 0;
        const counterInterval = setInterval(() => {
          seconds++;
          const dots = '.'.repeat((seconds % 4));
          
          if (seconds <= 8) {
            statusEl.innerHTML = `üîç Analyzing your image${dots}<br><small>Using Venice.ai | ${seconds}s elapsed</small>`;
          } else {
            statusEl.innerHTML = `üêï Adding $dog ${dots}<br><small>Using Venice.ai | ${seconds}s elapsed</small>`;
          }
        }, 1000);
        
        const dogImageData = await fetchImageAsDataURL(specialDogURL);
        
        const response = await fetch(`/.netlify/functions/${functionName}`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            userImage: capturedImageData,
            dogImage: dogImageData,
            model: 'venice'
          })
        });

        clearInterval(counterInterval);

        if (!response.ok) {
          const text = await response.text();
          console.error('Server response:', text);
          throw new Error(`Server error: ${response.status}`);
        }

        const result = await response.json();
        if (!result.ok) throw new Error(result.error);

        dogifiedImgEl.src = result.generatedImageUrl;
        dogifiedImgEl.style.display = 'block';
        
        captureLeftBtn.style.background = '#28a745';
        captureRightBtn.style.background = '#28a745';
        
        // Save image to Supabase for stable sharing URL (only if toggle is enabled)
        let finalImageUrl = result.generatedImageUrl;
        let shareableUrl = window.location.href;
        const saveToggle = document.getElementById('save-toggle');
        const shouldSave = saveToggle && saveToggle.checked;
        
        if (shouldSave && result.saveToSupabase) {
          statusEl.innerHTML = `üîÑ <strong>Saving image...</strong><br><small>Compressing for faster sharing</small>`;
          
          try {
            // Compress the image before sending to reduce size
            let imageDataToSave = result.generatedImageUrl;
            
            // If it's a data URL, try to compress it
            if (result.generatedImageUrl.startsWith('data:image/')) {
              try {
                // Create canvas to compress image
                const img = new Image();
                img.crossOrigin = 'anonymous';
                
                await new Promise((resolve, reject) => {
                  img.onload = resolve;
                  img.onerror = reject;
                  img.src = result.generatedImageUrl;
                });
                
                // Create canvas with 600x600 size for consistency
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                
                // Standardize to 600x600 for all saved images
                const targetSize = 600;
                canvas.width = targetSize;
                canvas.height = targetSize;
                
                // Draw image to fill the 600x600 canvas (may crop if aspect ratio doesn't match)
                ctx.drawImage(img, 0, 0, targetSize, targetSize);
                
                // Convert to JPEG with 80% quality for good balance of size/quality
                imageDataToSave = canvas.toDataURL('image/jpeg', 0.8);
                
                console.log('Compressed image from', Math.round(result.generatedImageUrl.length / 1024), 'KB to', Math.round(imageDataToSave.length / 1024), 'KB');
                console.log('Compressed image details:', {
                  startsWithDataJpeg: imageDataToSave.startsWith('data:image/jpeg'),
                  hasBase64: imageDataToSave.includes('base64,'),
                  firstChars: imageDataToSave.substring(0, 50),
                  lengthAfterComma: imageDataToSave.split(',')[1]?.length || 0
                });
                
              } catch (compressionError) {
                console.log('Image compression failed, using original:', compressionError.message);
                // Use original if compression fails
              }
            }
            
            console.log('About to send to backend:', {
              dataType: typeof imageDataToSave,
              dataLength: imageDataToSave.length,
              startsWithData: imageDataToSave.startsWith('data:'),
              firstChars: imageDataToSave.substring(0, 30)
            });
            
            const saveResponse = await fetch('/.netlify/functions/save-dogify-image-storage', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({
                imageData: imageDataToSave,
                sceneAnalysis: result.sceneAnalysis || result.imageAnalysis,
                generationPrompt: result.placementPrompt || result.reproductionPrompt,
                modelUsed: result.visionModel || result.model,
                generationTimeSeconds: seconds,
                userSession: Date.now().toString() // Simple session ID
              })
            });
            
            if (saveResponse.ok) {
              const saveResult = await saveResponse.json();
              if (saveResult.ok) {
                finalImageUrl = saveResult.url; // Use the direct storage URL
                // Create proper shareable URL that will have static meta tags
                const imageId = saveResult.id;
                shareableUrl = `${window.location.origin}/share/${imageId}`;
                console.log('Image saved to Supabase:', imageId);
                console.log('Shareable URL created:', shareableUrl);
              }
            } else {
              const errorResult = await saveResponse.json().catch(() => ({}));
              if (saveResponse.status === 503) {
                console.warn('Image saving service not configured - using Venice URL directly');
              } else {
                console.warn('Failed to save to Supabase:', errorResult);
              }
            }
          } catch (saveErr) {
            console.warn('Failed to save to Supabase:', saveErr);
            // Continue with original URL if save fails
          }
        } else if (!shouldSave) {
          console.log('User opted not to save image - using Venice URL directly');
        }
        
        // Show and update share bar with final image URL
        const shareContainer = document.getElementById('share-container');
        
        // For proper social media sharing, we need the URLs in static HTML
        // So instead of trying to update this page, we'll create a shareable URL
        let shareMessage = '';
        
        if (shareableUrl !== window.location.href) {
          // Image was saved to Supabase - we have a proper shareable URL with static meta tags
          shareMessage = '‚úÖ Shareable link created with embedded image for social media';
        } else {
          shareMessage = '‚ö†Ô∏è Using temporary image URL (may not work on social media)';
        }
        
        // Create share section with copy link functionality
        shareContainer.innerHTML = `
          <div style="text-align: center; margin: 1rem 0;">
            <div style="font-weight: 600; margin-bottom: 0.5rem;">Share your $dogified photo:</div>
            <div style="margin: 0.5rem 0; padding: 0.5rem; background: #f0f0f0; border-radius: 4px;">
              <input type="text" id="share-url" value="${shareableUrl}" readonly 
                     style="width: 80%; padding: 0.5rem; border: 1px solid #ccc; border-radius: 4px; font-size: 0.9rem;">
              <button onclick="copyShareUrl()" style="padding: 0.5rem 1rem; margin-left: 0.5rem; background: #0070f3; color: white; border: none; border-radius: 4px; cursor: pointer;">
                üìã Copy Link
              </button>
            </div>
            <div style="font-size: 0.8rem; color: #666; margin-bottom: 1rem;">${shareMessage}</div>
            <div class='a2a_kit a2a_kit_size_24 a2a_default_style' 
                 data-a2a-url='${shareableUrl}' 
                 data-a2a-title='Check out my $DOGified photo!' 
                 data-a2a-description='I used AI to add a cute dog to my photo! Create your own at dothink.in'>
              <a class='a2a_button_facebook'></a>
              <a class='a2a_button_twitter'></a>
              <a class='a2a_button_linkedin'></a>
              <a class='a2a_dd' href='https://www.addtoany.com/share'></a>
            </div>
          </div>
        `;
        
        // Add CSS class based on whether image was saved
        shareContainer.className = finalImageUrl !== result.generatedImageUrl ? 'saved-url' : 'temp-url';
        
        console.log('Created share section with URL:', shareableUrl);
        
        // Show the share container
        shareContainer.style.display = 'block';
        
        // Initialize AddToAny on the new widget
        setTimeout(() => {
          if (window.a2a && window.a2a.init_all) {
            window.a2a.init_all('page');
          }
        }, 100);
        
        // Populate technical details
        sceneAnalysisEl.textContent = result.sceneAnalysis || result.imageAnalysis || 'No analysis available';
        generationPromptEl.textContent = result.placementPrompt || result.reproductionPrompt || 'No prompt available';
        techDetails.style.display = 'block';
        
        statusEl.innerHTML = `
          ‚ú® <strong>$dog Added!</strong> (${seconds}s)<br>
          <small>Using ${result.visionModel || result.model} | Refresh to try again</small>
        `;
        
      } catch (err) {
        console.error('$dogify error:', err);
        statusEl.innerHTML = `üö® <strong>Error:</strong> ${err.message}<br><small>Try refreshing to capture a new photo</small>`;
        captureLeftBtn.style.background = '#dc3545';
        captureRightBtn.style.background = '#dc3545';
      }
    }

    // Add dogify listeners to both buttons (removed since we're adding them dynamically)
    // dogifyLeftBtn.addEventListener('click', dogifyPhoto);
    // dogifyRightBtn.addEventListener('click', dogifyPhoto);
  </script>

  <div class="powered-by">
    <span class="powered-by-text">Powered by <a href="https://venice.ai/chat?ref=aHYnVr" target="_blank">Venice.ai</a></span>
    <a href="https://venice.ai/chat?ref=aHYnVr" target="_blank"><img src="/assets/images/venice-logo-lockup-black.svg" alt="Venice.ai" class="venice-logo" /></a>
  <br>
  <a href="https://github.com/msjogren822/dothinksite">  
  <svg class="octicon octicon-mark-github v-align-middle" height="24" viewBox="0 0 16 16" version="1.1" width="24" aria-hidden="true"><path fill-rule="evenodd" d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0016 8c0-4.42-3.58-8-8-8z"></path></svg> view source</a>
  </div>
</body>
</html>
